#pragma once

#ifndef _N4409_PARALLELSTL
#define _N4409_PARALLELSTL
#endif

#define __NOEXCEPT noexcept

#include <experimental/parallel/execution_policy>

namespace std          {
namespace experimental {
namespace parallel     {
inline namespace v1    {


#if 0
// for_each
//
struct __for_each {};
template<class ExecutionPolicy, class InputIt, class Unary>
typename __enable_if_execution_policy<ExecutionPolicy>::type  
for_each(ExecutionPolicy &&exec, InputIt first, InputIt last, Unary f)
{
    exec.dispatch(__for_each{}, first, last, f);
}

// for_each_n
//
struct __for_each_n{};
template<class ExecutionPolicy, class InputIt, class Size, class Unary, typename __enable_if_execution_policy<ExecutionPolicy, InputIt>::type* = nullptr>  
InputIt for_each_n(ExecutionPolicy &&exec, InputIt first, Size n, Unary f)
{
   return exec.dispatch(__for_each_n{}, first, n, f);
}

// sort
//
struct __sort{};
template<class ExecutionPolicy, class RandomIt>
typename __enable_if_execution_policy<ExecutionPolicy>::type  
sort(ExecutionPolicy &&exec, RandomIt first, RandomIt last)
{
    exec.dispatch(__sort{}, first, last);
}
#else

#define __DECLARE_PSTL(name) \
struct __##name{}; \
template<class ExecutionPolicy, class... Args> \
typename __enable_if_execution_policy< \
    ExecutionPolicy, \
    decltype(declval<ExecutionPolicy>().dispatch(__##name{}, declval<Args>()...)) \
 >::type \
name(ExecutionPolicy &&exec, Args&&... args) \
{ \
   return exec.dispatch(__##name{}, forward<Args>(args)...); \
}

__DECLARE_PSTL(for_each)
__DECLARE_PSTL(for_each_n)
__DECLARE_PSTL(sort)

#undef __DECLARE_PSTL

#endif



}
}
}
}

#include <experimental/parallel/detail/sequential_policy.hpp>
#include <experimental/parallel/detail/parallel_policy.hpp>
#include <experimental/parallel/detail/dynamic_policy.hpp>


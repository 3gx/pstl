#pragma once

#ifndef _N4409_PARALLELSTL
#define _N4409_PARALLELSTL
#endif

#define __NOEXCEPT noexcept


namespace std          {
namespace experimental {
namespace parallel     {
inline namespace v1    {

namespace details
{
    struct for_each;
    struct sort;
}


}
}
}
}

#include <experimental/parallel/execution_policy>
#include <experimental/parallel/details/sequential_policy.hpp>
#include <experimental/parallel/details/parallel_policy.hpp>
 #include <experimental/parallel/details/dynamic_policy.hpp>

namespace std          {
namespace experimental {
namespace parallel     {
inline namespace v1    {

namespace details
{
    struct for_each
    {
        template<class ExecutionPolicy, class InputOperator, class Function>
        void operator()(ExecutionPolicy &&exec, InputOperator first, InputOperator last, Function f) const
        {
            dispatch(*this, std::forward<ExecutionPolicy>(exec), first, last, f);
        }
    };

    struct sort
    {
        template<class ExecutionPolicy, class RandomIt>
        void operator()(ExecutionPolicy &&exec, RandomIt first, RandomIt last) const
        {
            dispatch(*this, std::forward<ExecutionPolicy>(exec), first, last);
        }
    };
}



template<class ExecutionPolicy, class InputIterator, class Function>
typename __enable_if_execution_policy<ExecutionPolicy>::type  
for_each(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Function f)
{
    details::for_each{}(std::forward<ExecutionPolicy>(exec), first, last, f);
}

template<class ExecutionPolicy, class RandomIt>
typename __enable_if_execution_policy<ExecutionPolicy>::type  
sort(ExecutionPolicy &&exec, RandomIt first, RandomIt last)
{
    details::sort{}(std::forward<ExecutionPolicy>(exec), first, last);
}
const static sequential_execution_policy seq{};
const static parallel_execution_policy par{};

}
}
}
}


